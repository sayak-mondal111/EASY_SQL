alter table [table] add [value] [value];
alter table [table] add column [field] [value];
alter table [table] add constraint [value] foreign key ([field]) references [table]([field]);
alter table [table] add constraint [value] primary key ([field]);
alter table [table] add foreign key ([field]) references [table]([field]);
alter table [table] add primary key ([field]);
alter table [table] drop column [field];
alter table [table] drop column [value];
alter table [table] modify column [field] [value];
alter table [table] modify column [value] [value];
alter table [table] rename column [value] to [value];
alter table [table] rename to [value];
alter table [table] rename to [value];
begin transaction;
commit;
create database [value];
create index [value] on [table] ([field]);
create table [table] ([field] [value] check ([field] > [value]));
create table [table] ([field] [value] default [value]);
create table [table] ([field] [value] unique);
create table [table] ([field] [value], [field] [value]);
create table [table] ([field] int check ([field] > [value]));
create table [table] ([field] int default [value]);
create table [table] ([field] int unique);
create table [table] ([field] int, [field] varchar(255));
create table [table] as select [field] from [value];
create view [value] as select [field] from [table];
delete from [table] where [condition];
delete from [table] where [field] < [value];
delete from [table] where [field] = [value] and [field] < [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] <> [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] <> [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value] and [field] <> [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value] and [field] between [value] and [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value] and [field] in ([value], [value], [value]);
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value] and [field] is not null;
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value] and [field] is null;
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value] and [field] like [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] between [value] and [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] in ([value], [value], [value]);
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] is not null;
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] is null;
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] and [field] like [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value] or [field] = [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] = [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] > [value] and [field] < [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] between [value] and [value];
delete from [table] where [field] = [value] and [field] = [value] and [field] in ([value], [value], [value]);
delete from [table] where [field] = [value] and [field] = [value] and [field] is not null;
delete from [table] where [field] = [value] and [field] = [value] and [field] is null;
delete from [table] where [field] = [value] and [field] = [value] and [field] like [value];
delete from [table] where [field] = [value] and [field] = [value] limit [value];
delete from [table] where [field] = [value] and [field] = [value] or [field] = [value] or [field] = [value];
delete from [table] where [field] = [value] and [field] = [value] or [field] = [value];
delete from [table] where [field] = [value] and [field] = [value] order by [field] desc limit [value];
delete from [table] where [field] = [value] and [field] = [value];
delete from [table] where [field] = [value] and [field] > [value];
delete from [table] where [field] = [value] and [field] between [value] and [value];
delete from [table] where [field] = [value] and [field] in ([value], [value], [value]);
delete from [table] where [field] = [value] and [field] is not null;
delete from [table] where [field] = [value] and [field] is null;
delete from [table] where [field] = [value] and [field] like [value];
delete from [table] where [field] = [value] limit [value];
delete from [table] where [field] = [value] or [field] = [value] or [field] = [value];
delete from [table] where [field] = [value] or [field] = [value];
delete from [table] where [field] = [value] order by [field] desc limit [value];
delete from [table] where [field] = [value];
delete from [table] where [field] > [value];
delete from [table] where [field] between [value] and [value];
delete from [table] where [field] in ([value], [value], [value]);
delete from [table] where [field] is not null;
delete from [table] where [field] is null;
delete from [table] where [field] like [value];
delete from [table] where not [field] = [value];
delete from [table], [table] using [table] join [table] on [condition] where [value];
delete from [table];
drop index [value];
drop table [table];
drop view [value];
execute immediate 'select * from [table]';
exit;
grant select on [table] to [value];
grant select, insert on [table] to [value];
insert into [table] ([field]) values ([value], [value]) on conflict ([field]) do nothing;
insert into [table] ([field]) values ([value], [value]) on conflict ([field]) do update set [field] = [value];
insert into [table] ([field]) values ([value], [value]) on duplicate key update [field] = [value], [field] = [value];
insert into [table] ([field]) values ([value], [value]) on duplicate key update [field] = values([field]), [field] = values([field]);
insert into [table] ([field]) values ([value], [value]) returning *;
insert into [table] ([field]) values ([value], [value]) returning [field];
insert into [table] ([field]) values ([value], [value]), ([value], [value]);
insert into [table] ([field]) values ([value], [value]);
insert into [table] ([field]) values ([value], default);
insert into [table] ([field]) values ([value], null);
insert into [table] ([field]) values (default, [value]);
insert into [table] ([field]) values (null, [value]);
insert into [table] ([field], [field]) values ([value], [value], [value]), ([value], [value], [value]);
insert into [table] ([field], [field]) values ([value], [value], [value]);
insert into [table] ([field], [field]) values ([value], [value], [value], [value]), ([value], [value], [value], [value]);
insert into [table] ([field], [field]) values ([value], [value], [value], [value]);
insert into [table] values ([value], [value]);
merge into [table] using [table] on [condition] when matched then update set [field] = [value] when not matched then insert ([field]) values ([value]);
revoke delete on [table] from [value];
rollback to [value];
rollback;
savepoint [value];
select * from [field] where [field] > [value];
select * from [table] cross join [table];
select * from [table] full outer join [table] on [table].[value] = [table].[value];
select * from [table] inner join [table] on [table].[value] = [table].[value];
select * from [table] left join [table] on [table].[value] = [table].[value];
select * from [table] limit [value] offset [value];
select * from [table] natural join [table];
select * from [table] order by [field] asc limit [value];
select * from [table] order by [field] desc limit [value];
select * from [table] partition ([value]);
select * from [table] right join [table] on [table].[value] = [table].[value];
select * from [table] self join [table] [alias] on [table].[value] = [alias].[value];
select * from [table] start with [field] = [value] connect by prior [value] = [value];
select * from [table] where [field] < [value];
select * from [table] where [field] <> [value];
select * from [table] where [field] = [value];
select * from [table] where [field] between [value] and [value];
select * from [table] where [field] in ([value], [value]);
select * from [table] where [field] is null;
select * from [table] where [field] like '[value]';
select * from [table] where match([field]) against ('[value]');
select * from [table];
select [field] ->> '$.key' from [table];
select [field] as [alias] from [table];
select [field] as [alias], [field] from [table];
select [field] from [table] except select [field] from [table];
select [field] from [table] full outer join [table] on [table].[value] = [table].[value] where [field] is not null;
select [field] from [table] group by [field] having sum([field]) < [value];
select [field] from [table] intersect select [field] from [table];
select [field] from [table] join [table] on [table].[value] = [table].[value] where [field] > [value];
select [field] from [table] left join [table] on [table].[value] = [table].[value] where [field] is null;
select [field] from [table] order by [field] desc limit [value];
select [field] from [table] union all select [field] from [table];
select [field] from [table] union select [field] from [table];
select [field] from [table] where [field] = [value];
select [field] from [table];
select [field] from [table] cross join [table];
select [field] from [table] full outer join [table] on [table].[field] = [table].[field];
select [field] from [table] group by [field] having avg([field]) > [value];
select [field] from [table] group by [field] having count(*) > [value];
select [field] from [table] group by [field] having max([field]) > [value];
select [field] from [table] group by [field] having min([field]) < [value];
select [field] from [table] group by [field] having sum([field]) > [value];
select [field] from [table] group by [field];
select [field] from [table] having count(*) > [value];
select [field] from [table] inner join [table] on [table].[field] = [table].[field];
select [field] from [table] join [table] on [table].[field] = [table].[field];
select [field] from [table] left join [table] on [table].[field] = [table].[field];
select [field] from [table] limit [value];
select [field] from [table] limit [value];
select [field] from [table] limit [value];
select [field] from [table] offset [value];
select [field] from [table] order by [field] asc;
select [field] from [table] order by [field] desc limit [value];
select [field] from [table] order by [field] desc;
select [field] from [table] right join [table] on [table].[field] = [table].[field];
select [field] from [table] where [field] < [value];
select [field] from [table] where [field] < [value];
select [field] from [table] where [field] < [value];
select [field] from [table] where [field] <= [value];
select [field] from [table] where [field] <> [value];
select [field] from [table] where [field] = [value] and [field] < [value];
select [field] from [table] where [field] = [value] and [field] < [value];
select [field] from [table] where [field] = [value] and [field] <> [value];
select [field] from [table] where [field] = [value] and [field] <> [value];

select [field] from [table] where [field] = [value] or [field] < [value];
select [field] from [table] where [field] = [value] or [field] < [value];
select [field] from [table] where [field] = [value] or [field] <> [value];
select [field] from [table] where [field] = [value] or [field] <> [value];
select [field] from [table] where [field] > [value] and [field] < [value];
select [field] from [table] where [field] > [value] and [field] < [value];
select [field] from [table] where [field] > [value] and [field] <> [value];
select [field] from [table] where [field] > [value] and [field] <> [value];

select [field] from [table] where [field] > [value] or [field] < [value];
select [field] from [table] where [field] > [value] or [field] < [value];
select [field] from [table] where [field] > [value] or [field] <> [value];
select [field] from [table] where [field] > [value] or [field] <> [value];

select [field] from [table] where [field] = [value] and [field] = [value] and [field] <> [value];
select [field] from [table] where [field] = [value] and [field] = [value] and [field] <> [value];
select [field] from [table] where [field] = [value] and [field] = [value] and [field] = [value];
select [field] from [table] where [field] = [value] and [field] = [value] and [field] = [value];
select [field] from [table] where [field] = [value] and [field] = [value] and [field] between [value] and [value];
select [field] from [table] where [field] = [value] and [field] = [value] and [field] between [value] and [value];
select [field] from [table] where [field] = [value] and [field] = [value] and [field] in ([value], [value], [value]);
select [field] from [table] where [field] = [value] and [field] = [value] and [field] in ([value], [value], [value]);
select [field] from [table] where [field] = [value] and [field] = [value] and [field] is not null;
select [field] from [table] where [field] = [value] and [field] = [value] and [field] is not null;
select [field] from [table] where [field] = [value] and [field] = [value] and [field] is null;
select [field] from [table] where [field] = [value] and [field] = [value] and [field] is null;
select [field] from [table] where [field] = [value] and [field] = [value] and [field] like [value];
select [field] from [table] where [field] = [value] and [field] = [value] and [field] like [value];

select [field] from [table] where [field] < [value] and [field] < [value] and [field] <> [value];
select [field] from [table] where [field] < [value] and [field] = [value] and [field] <> [value];
select [field] from [table] where [field] < [value] and [field] = [value] and [field] = [value];
select [field] from [table] where [field] < [value] and [field] = [value] and [field] = [value];
select [field] from [table] where [field] < [value] and [field] = [value] and [field] between [value] and [value];
select [field] from [table] where [field] < [value] and [field] = [value] and [field] between [value] and [value];
select [field] from [table] where [field] < [value] and [field] = [value] and [field] in ([value], [value], [value]);
select [field] from [table] where [field] > [value] and [field] = [value] and [field] in ([value], [value], [value]);
select [field] from [table] where [field] > [value] and [field] = [value] and [field] is not null;
select [field] from [table] where [field] > [value] and [field] = [value] and [field] is not null;
select [field] from [table] where [field] > [value] and [field] = [value] and [field] is null;
select [field] from [table] where [field] > [value] and [field] = [value] and [field] is null;
select [field] from [table] where [field] > [value] and [field] = [value] and [field] like [value];
select [field] from [table] where [field] > [value] and [field] = [value] and [field] like [value];

select [field] from [table] where [field] = [value] and [field] = [value];
select [field] from [table] where [field] = [value] and [field] = [value];
select [field] from [table] where [field] = [value] and [field] > [value] and [field] < [value];
select [field] from [table] where [field] = [value] and [field] > [value] and [field] < [value];
select [field] from [table] where [field] = [value] and [field] > [value];
select [field] from [table] where [field] = [value] and [field] > [value];
select [field] from [table] where [field] = [value] and [field] between [value] and [value];
select [field] from [table] where [field] = [value] and [field] between [value] and [value];
select [field] from [table] where [field] = [value] and [field] in ([value], [value], [value]);
select [field] from [table] where [field] = [value] and [field] in ([value], [value], [value]);
select [field] from [table] where [field] = [value] and [field] is not null;
select [field] from [table] where [field] = [value] and [field] is not null;
select [field] from [table] where [field] = [value] and [field] is null;
select [field] from [table] where [field] = [value] and [field] is null;
select [field] from [table] where [field] = [value] and [field] like [value];
select [field] from [table] where [field] = [value] and [field] like [value];
select [field] from [table] where [field] = [value] except select [field] from [table] where [field] = [value];
select [field] from [table] where [field] = [value] group by [field];
select [field] from [table] where [field] = [value] having count(*) > [value];
select [field] from [table] where [field] = [value] intersect select [field] from [table] where [field] = [value];
select [field] from [table] where [field] = [value] limit [value];
select [field] from [table] where [field] = [value] or [field] = [value] or [field] = [value];
select [field] from [table] where [field] = [value] or [field] = [value] or [field] = [value];
select [field] from [table] where [field] = [value] or [field] = [value];
select [field] from [table] where [field] = [value] or [field] = [value];
select [field] from [table] where [field] = [value] order by [field] asc;
select [field] from [table] where [field] = [value] order by [field] desc limit [value];
select [field] from [table] where [field] = [value] order by [field] desc;
select [field] from [table] where [field] = [value] union all select [field] from [table] where [field] = [value];
select [field] from [table] where [field] = [value] union select [field] from [table] where [field] = [value];
select [field] from [table] where [field] = [value];
select [field] from [table] where [field] = [value];
select [field] from [table] where [field] = [value];
select [field] from [table] where [field] > [value];
select [field] from [table] where [field] > [value];
select [field] from [table] where [field] > [value];
select [field] from [table] where [field] >= [value];
select [field] from [table] where [field] between [value] and [value];
select [field] from [table] where [field] between [value] and [value];
select [field] from [table] where [field] between [value] and [value];
select [field] from [table] where [field] in ([value], [value]);
select [field] from [table] where [field] in ([value], [value], [value]);
select [field] from [table] where [field] in ([value], [value], [value]);
select [field] from [table] where [field] is not null;
select [field] from [table] where [field] is not null;
select [field] from [table] where [field] is null;
select [field] from [table] where [field] is null;
select [field] from [table] where [field] like '[value]';
select [field] from [table] where [field] like [value];
select [field] from [table] where [field] like [value];
select [field] from [table] where [value] = [value];
select [field] from [table] where not [field] = [value];
select [field] from [table];
select [field] from [table];
select [field], case when [condition] then [value] else [value] end from [table];
select [field], avg([field]) from [table] group by [field] having avg([field]) > [value];
select [field], avg([field]) from [table] group by [field];
select [field], avg([field]) from [table] where [field] = [value] group by [field];
select [field], avg([field]) from [table] where [field] like '[value]' group by [field];
select [field], coalesce([field], [value]) from [table] where [field] < [value];
select [field], count(*) from [table] group by [field] having count(*) > [value];
select [field], count(*) from [table] group by [field];
select [field], count(*) from [table] where [field] = [value] group by [field];
select [field], count([field]) from [table] group by [field] having count([field]) > [value];
select [field], count([field]) from [table] group by [field];
select [field], lag([field], 1) over (order by [field]) from [table];
select [field], lead([field], 1) over (order by [field]) from [table];
select [field], max([field]) from [table] group by [field];
select [field], max([field]) from [table] where [field] = [value] group by [field];
select [field], max([field]) from [table] where [field] between [value] and [value] group by [field];
select [field], min([field]) from [table] group by [field];
select [field], min([field]) from [table] where [field] = [value] group by [field];
select [field], rank() over (order by [field]) from [table];
select [field], rank() over (partition by [field] order by [field]) from [table];
select [field], row_number() over (order by [field]) from [table];
select [field], row_number() over (partition by [field] order by [field]) from [table];
select [field], sum([field]) from [table] group by [field];
select [field], sum([field]) from [table] where [field] = [value] group by [field];
select [field], sum([field]) over (partition by [field]) from [table];
select [table].[field], [table].[field] from [table] full outer join [table] on [table].[value] = [table].[value];
select [table].[field], [table].[field] from [table] inner join [table] on [table].[value] = [table].[value];
select [table].[field], [table].[field] from [table] left join [table] on [table].[value] = [table].[value];
select [table].[field], [table].[field] from [table] right join [table] on [table].[value] = [table].[value];
select [value] ->> '$.key' from [table];
select abs([field]) from [table];
select avg([field] * [field]) from [table];
select avg([field]) from [table];
select case when [field] > [value] then 'high' else 'low' end from [table];
select cast([field] as date) from [table];
select ceil([field]) from [table];
select coalesce([field], [value]) from [table];
select coalesce([field], [value]) from [table];
select concat([field]) from [table];
select count([field]) from [table];
select count(distinct [field]) from [table];
select date_add([value], interval [value] day) from [table];
select datediff([value], [value]) from [table];
select distinct [field] from [table] cross join [table] where [table].[value] = [table].[value];
select distinct [field] from [table] where [field] < [value];
select distinct [field] from [table] where [field] <> [value];
select distinct [field] from [table] where [field] = [value];
select distinct [field] from [table] where [field] > [value];
select distinct [field] from [table];
select extract(year from [value]) from [table];
select floor([field]) from [table];
select group_concat([field]) from [table];
select length([field]) from [table];
select log([field]) from [table];
select lower([field]) from [table];
select max([field]) from [table];
select min([field]) from [table];
select mod([field], [value]) from [table];
select nullif([field], [value]) from [table];
select power([field], [value]) from [table];
select round([field], [value]) from [table];
select sqrt([field]) from [table];
select stddev([field]) from [table];
select substring([field], [value], [value]) from [table];
select sum([field] + [field]) from [table];
select sum([field]) from [table];
select sum(case when [field] > [value] then 1 else 0 end) from [table];
select top [value] * from [table];
select trim([field]) from [table];
select upper([field]) from [table];
select variance([field]) from [table];
select xmlquery('//node' passing [value]) from [table];
truncate table [table];
update [table] set [field] = [value] where [condition];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] <> [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] <> [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] and [field] <> [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] and [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] and [field] between [value] and [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] and [field] in ([value], [value], [value]);
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] and [field] is not null;
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] and [field] is null;
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] and [field] like [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] > [value] and [field] < [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] between [value] and [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] in ([value], [value], [value]);
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] is not null;
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] is null;
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] and [field] like [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] or [field] = [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] > [value] and [field] < [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] between [value] and [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] in ([value], [value], [value]);
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] is not null;
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] is null;
update [table] set [field] = [value], [field] = [value] where [field] = [value] and [field] like [value];

update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] <> [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] and [field] <> [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] and [field] = [value] and [field] <> [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] or [field] = [value] and [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] and [field] = [value] and [field] between [value] and [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] or [field] = [value] and [field] in ([value], [value], [value]);
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] <> [value] and [field] = [value] and [field] is not null;
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] and [field] = [value] and [field] is null;
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] or [field] = [value] and [field] like [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] < [value] and [field] = [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] and [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] > [value] and [field] > [value] and [field] < [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] = [value] or [field] between [value] and [value];
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] < [value] and [field] in ([value], [value], [value]);
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] = [value] and [field] is not null;
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] > [value] or [field] is null;
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] = [value] and [field] like [value];
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] < [value] or [field] = [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] > [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] > [value] and [field] < [value];
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] between [value] and [value];
update [table] set [field] = [value], [field] = [value] where [field] > [value] and [field] in ([value], [value], [value]);
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] is not null;
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] is null;
update [table] set [field] = [value], [field] = [value] where [field] < [value] and [field] like [value];

update [table] set [field] = [value], [field] = [value] where [field] = [value] limit [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] or [field] = [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] or [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value] order by [field] desc limit [value];
update [table] set [field] = [value], [field] = [value] where [field] = [value];
update [table] set [field] = [value], [field] = [value] where [field] > [value];
update [table] set [field] = [value], [field] = [value] where [field] between [value] and [value];
update [table] set [field] = [value], [field] = [value] where [field] in ([value], [value], [value]);
update [table] set [field] = [value], [field] = [value] where [field] is null;
update [table] set [field] = [value], [field] = [value] where [field] like [value];
update [table] set [field] = [value], [field] = [value] where not [field] = [value];
update [table] set [field] = [value], [field] = [value];
update [table] set [field] = [value];
update [table] set [value] = json_set([value], '$.key', [value]);
update [table], [table] set [table].[field] = [table].[field] where [table].[value] = [table].[value];
with recursive [value] as (...) select * from [value];




INSERT INTO [table] ([field]) VALUES ([value]);
INSERT INTO [table] ([field]) VALUES ([value]), ([value]);
INSERT INTO [table] DEFAULT VALUES;
INSERT INTO [table] ([field]) SELECT [field] FROM [table] WHERE [condition];
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = VALUES([field]);
INSERT IGNORE INTO [table] ([field]) VALUES ([value]);
REPLACE INTO [table] ([field]) VALUES ([value]);
INSERT INTO [table] ([field]) VALUES ([value]) RETURNING [field];
INSERT INTO [table] ([field]) VALUES ([value]) PRIMARY KEY ([field]);
INSERT INTO [table] ([field]) VALUES ([value]) BEFORE INSERT;
INSERT INTO [table] PARTITION ([partition_name]) VALUES ([value]);
INSERT INTO [temp_table] ([field]) VALUES ([value]);
INSERT INTO [table] ([json_column]) VALUES ('{"key": "value"}');
INSERT INTO [table] ([xml_column]) VALUES ('value');
INSERT INTO [table] ([field]) VALUES (UPPER([value]));
INSERT INTO [table] ([date_column]) VALUES (CURRENT_DATE);
INSERT INTO [table] ([field]) VALUES (CASE WHEN [condition] THEN [value] ELSE [value] END);
INSERT INTO [table] ([field]) SELECT ROW_NUMBER() OVER (PARTITION BY [field] ORDER BY [field]);
INSERT INTO [table] SELECT [field] FROM [source_table];
INSERT INTO [table] ([field]) VALUES ([value]), ([value]);
WITH [alias] AS (SELECT [field] FROM [table]) INSERT INTO [table] ([field]) SELECT [field] FROM [alias];
INSERT INTO [table] ([field]) VALUES ([value]) ON CONFLICT ([field]) DO UPDATE SET [field] = [value];
MERGE INTO [table] USING [source_table] ON [condition] WHEN MATCHED THEN UPDATE SET [field] = [value] WHEN NOT MATCHED THEN INSERT ([field]) VALUES ([value]);
INSERT DELAYED INTO [table] ([field]) VALUES ([value]);
BEGIN TRANSACTION; INSERT INTO [table] ([field]) VALUES ([value]); COMMIT;
INSERT INTO [table] ([field]) VALUES ([value]) USE INDEX ([index_name]);
INSERT INTO [table] ([field]) VALUES ([value]) PARALLEL;
INSERT IGNORE INTO [table] ([field]) VALUES (CASE WHEN [condition] THEN [value] ELSE [value] END);
INSERT IGNORE INTO [table] ([field]) VALUES (UPPER([value]));
INSERT IGNORE INTO [table] ([field]) VALUES ('<node>value</node>');
INSERT IGNORE INTO [table] ([field]) VALUES ('{"key": "value"}');
INSERT IGNORE INTO [table] ([field]) SELECT [field] FROM [table] WHERE [condition];
INSERT IGNORE INTO [table] ([field]) SELECT ROW_NUMBER() OVER (ORDER BY [field]) FROM [table];
REPLACE INTO [table] ([field]) VALUES (CASE WHEN [condition] THEN [value] ELSE [value] END);
REPLACE INTO [table] ([field]) VALUES (UPPER([value]));
REPLACE INTO [table] ([field]) VALUES ('{"key": "value"}');
REPLACE INTO [table] ([field]) SELECT [field] FROM [table] WHERE [condition];
INSERT INTO [table] ([field]) VALUES ([value]) CHECK ([condition]);
INSERT INTO [table] ([field]) VALUES ([value]) UNIQUE ([field]);
INSERT INTO [table] ([field]) VALUES ([value]) FOREIGN KEY ([field]) REFERENCES [table]([field]);
INSERT INTO [table] ([field]) VALUES ([value]) INSTEAD OF INSERT;
INSERT INTO [table] ([field]) VALUES ([value]) AFTER INSERT;
INSERT INTO [table] ([field]) VALUES (LOWER([value]));
INSERT INTO [table] ([field]) VALUES (TRIM([value]));
INSERT INTO [table] ([field]) VALUES (CONCAT([value], [value]));
INSERT INTO [table] ([field]) VALUES (UPPER(TRIM([value])));
INSERT INTO [table] ([field]) VALUES (UPPER(CONCAT([value], [value])));
INSERT INTO [table] ([field]) VALUES (LOWER(TRIM([value])));
INSERT INTO [table] ([field]) VALUES (LOWER(CONCAT([value], [value])));
INSERT INTO [table] ([field]) VALUES (TRIM(CONCAT([value], [value])));
INSERT INTO [table] ([field]) VALUES (UPPER(LOWER(TRIM([value]))));
INSERT INTO [table] ([field]) VALUES (UPPER(LOWER(CONCAT([value], [value]))));
INSERT INTO [table] ([field]) VALUES (UPPER(TRIM(CONCAT([value], [value]))));
INSERT INTO [table] ([field]) VALUES (LOWER(TRIM(CONCAT([value], [value]))));
INSERT INTO [table] ([field]) VALUES (UPPER(LOWER(TRIM(CONCAT([value], [value])))));
INSERT INTO [table] ([field]) SELECT LEAD([field], 1) OVER (ORDER BY [field]) FROM [table];
INSERT INTO [table] ([field]) SELECT LAG([field], 1) OVER (ORDER BY [field]) FROM [table];
INSERT INTO [table] ([field]) SELECT RANK() OVER (ORDER BY [field]) FROM [table];
INSERT INTO [table] ([field]) SELECT ROW_NUMBER() OVER (ORDER BY [field]) FROM [table];
INSERT INTO [table] ([field]) SELECT [field] FROM [table];
INSERT INTO [table] ([field]) SELECT DISTINCT [field] FROM [table];
INSERT INTO [table] ([field]) SELECT UPPER([field]) FROM [table];
INSERT INTO [table] ([field]) SELECT CURRENT_DATE FROM [table];
INSERT INTO [table] ([field]) SELECT CASE WHEN [condition] THEN [value] ELSE [value] END FROM [table];
INSERT INTO [table] ([field]) SELECT ROW_NUMBER() OVER (ORDER BY [field]) FROM [table];
INSERT INTO [table] ([field]) SELECT [field] FROM [table];
INSERT INTO [table] ([field]) SELECT [value];
INSERT INTO [table] ([field]) SELECT [field] FROM [table] WHERE [field];
INSERT INTO [table] ([field]) SELECT [value] WHERE [field];
INSERT INTO [table] ([field]) SELECT [alias].[field] FROM [table] AS [alias];
INSERT INTO [table] ([field]) SELECT [alias].[field] FROM [table] AS [alias] WHERE [alias].[field];
INSERT INTO [table] ([field]) SELECT [value] FROM DUAL;
INSERT INTO [table] ([field]) VALUES ([value]) RETURNING *;
INSERT INTO [table] ([field]) VALUES (UPPER([value])) RETURNING [field];
INSERT INTO [table] ([field]) SELECT ROW_NUMBER() OVER (ORDER BY [field]) FROM [table] RETURNING [field];
INSERT INTO [table] ([field]) VALUES (CASE WHEN [condition] THEN [value] ELSE [value] END);
INSERT INTO [table] ([field]) VALUES (NULLIF([field], [value]));
INSERT INTO [table] ([field]) VALUES (CAST([field] AS [type]));
INSERT INTO [table] ([field]) VALUES (COALESCE([field], [default_value]));
INSERT INTO [table] ([field]) VALUES (UPPER([value])), (LOWER([value]));
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = UPPER([field]);
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = TRIM([field]);
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = LOWER([field]);
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = CONCAT([field], '_suffix');
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = SUBSTRING([field], 1, 5);
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = LENGTH([field]);
INSERT INTO [table] ([field]) VALUES ([value]) ON DUPLICATE KEY UPDATE [field] = UPPER(TRIM([field]));
INSERT INTO [table] ([field]) SELECT [field] FROM [table] WHERE [field] = [condition];
INSERT INTO [table] ([field]) SELECT UPPER([field]) FROM [table] WHERE [field] = [condition];
INSERT INTO [table] ([field]) SELECT DISTINCT [field] FROM [table] WHERE [field] = [condition];
INSERT INTO [table] ([field]) SELECT [field] FROM [table];
INSERT INTO [table] ([field]) SELECT DISTINCT [field] FROM [table];
INSERT INTO [table] ([field]) SELECT UPPER([field]) FROM [table];
INSERT INTO [table] ([field]) SELECT ROW_NUMBER() OVER (ORDER BY [field]) FROM [table];
INSERT INTO [table] ([field]) VALUES (NULL);
INSERT INTO [table] ([field]) VALUES (TRIM([value]));
INSERT INTO [table] ([field]) VALUES (LOWER([value]));
INSERT INTO [table] ([field]) VALUES ([value]) FOREIGN KEY ([field]) REFERENCES [table]([field]);
INSERT INTO [table] ([field]) VALUES ([value]) UNIQUE ([field]);
INSERT INTO [table] ([field]) VALUES ([value]) CHECK ([condition]);
INSERT INTO [table] ([field]) VALUES ([value]) PRIMARY KEY ([field]) UNIQUE ([field]) CHECK ([condition]);
INSERT IGNORE INTO [table] ([field]) VALUES (UPPER([value]));
INSERT IGNORE INTO [table] ([field]) VALUES (LOWER([value]));
INSERT IGNORE INTO [table] ([field]) VALUES (TRIM([value]));
INSERT IGNORE INTO [table] ([field]) VALUES (LENGTH([value]));
INSERT IGNORE INTO [table] ([field]) VALUES (UPPER(TRIM([value])));
INSERT IGNORE INTO [table] ([field]) VALUES (SUBSTRING([value], 1, 5));
INSERT IGNORE INTO [table] ([field]) VALUES (REPLACE([value], 'old', 'new'));


INSERT INTO [table] ([date_column]) VALUES (DATE_ADD(CURRENT_DATE, INTERVAL [number] DAY));
INSERT INTO [table] ([field]) VALUES (CURRENT_DATE), (DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY));
INSERT INTO [table] ([field]) SELECT CURRENT_DATE FROM [table] WHERE [field] = [condition];
INSERT INTO [table] ([date_column]) VALUES (DATE_ADD([date_field], INTERVAL [number] DAY));
INSERT INTO [table] ([date_column]) VALUES (EXTRACT(YEAR FROM [date_field]));
INSERT INTO [table] ([date_column]) VALUES (CURRENT_DATE);



DROP DATABASE [database_name];
DROP DATABASE IF EXISTS [database_name];
DROP TABLE IF EXISTS [table];
DROP TABLE IF EXISTS [table];
DROP VIEW [view_name];
DROP VIEW IF EXISTS [field];
DROP INDEX IF EXISTS [index_name] ON [table];
DROP INDEX [index_name] ON [table];



UPDATE [table] SET [field] = [field] + [value];  
UPDATE [table] SET [field] = [field] - [value];  
UPDATE [table] SET [field] = [field] * [value];  
UPDATE [table] SET [field] = [field] / [value];  
UPDATE [table] SET [field] = [field] || [value];  
UPDATE [table] SET [field] = UPPER([field]);
UPDATE [table] SET [field] = LOWER([field]); 
UPDATE [table] SET [field] = TRIM([field]);  
UPDATE [table] SET [field] = SUBSTRING([field], [start], [length]);  
UPDATE [table] SET [field] = CURRENT_DATE;
UPDATE [table] SET [field] = DATE_ADD([field], INTERVAL [number] DAY); 
UPDATE [table] SET [field] = COALESCE([field], [default_value]);  
UPDATE [table] SET [field] = CASE WHEN [condition] THEN [value] ELSE [value] END;
UPDATE [table] SET [field] = CAST([field] AS [type]);

 
UPDATE [table] SET [field] = [new_value] WHERE [field] <> [value]
UPDATE [table] SET [field] = [new_value] WHERE [field] < [value]  
UPDATE [table] SET [field] = [new_value] WHERE [field] > [value]
UPDATE [table] SET [field] = [new_value] WHERE [field] <= [value] 
UPDATE [table] SET [field] = [new_value] WHERE [field] >= [value]
UPDATE [table] SET [field] = [new_value] WHERE [field] BETWEEN [value1] AND [value2]  
UPDATE [table] SET [field] = [new_value] WHERE [field] IN ([value1], [value2])  
UPDATE [table] SET [field] = [new_value] WHERE [field] LIKE '[pattern]'  
UPDATE [table] SET [field] = [new_value] WHERE [field] IS NULL  
UPDATE [table] SET [field] = [new_value] WHERE [field] IS NOT NULL


UPDATE [table] SET [field] = REPLACE([field], '[old_value]', '[new_value]');
UPDATE [table] SET [field] = CONCAT([prefix], [field], [suffix]) WHERE [condition];
UPDATE [table] SET [field] = ROUND([field], [decimal_places]);
UPDATE [table] SET [field] = FLOOR(RAND() * [max_value]) WHERE [condition];
UPDATE [table] SET [field1] = [field2], [field2] = [field1];
UPDATE [table] SET [length_field] = LENGTH([field]);
UPDATE [table] SET [field] = CONCAT([field], ' ', NOW());
UPDATE [table] SET [json_field] = JSON_SET([json_field], '$.key', '[new_value]');
UPDATE [table] SET [full_name] = CONCAT_WS(' ', [first_name], [last_name]);
UPDATE [table] SET [field] = UNIX_TIMESTAMP([date_field]);


UPDATE [table] SET [field] = IF([condition], [value1], [value2]);
UPDATE [table] SET [field] = [another_field] * [multiplier];
UPDATE [table] SET [field] = FORMAT([field], [decimal_places]);
UPDATE [table] SET [year_field] = YEAR([date_field]);
UPDATE [table] SET [field] = '[default_value]' WHERE [field] IS NULL;
UPDATE [table] SET [field] = MD5([field]);
UPDATE [table] SET [field] = SHA2([field], 256);
UPDATE [table] SET [uuid_field] = UUID();
UPDATE [table] SET [field] = LPAD([field], [total_length], '0');
UPDATE [table] SET [field] = RPAD([field], [total_length], ' ');
UPDATE [table] SET [field] = REVERSE([field]);
UPDATE [table] SET [field] = (SELECT AVG([column]) FROM [other_table]);
UPDATE [table] SET [full_address] = CONCAT([street], ', ', [city], ', ', [state]);
UPDATE [table] SET [field] = LEFT([field], [number_of_characters]);
UPDATE [table] SET [field] = RIGHT([field], [number_of_characters]);
UPDATE [table] SET [updated_at] = NOW();
UPDATE [table] SET [backup_field] = [original_field];
UPDATE [table] SET [field] = REPEAT('*', LENGTH([field]));
UPDATE [table] SET [field] = [new_value] WHERE [condition] LIMIT 1;
UPDATE [table] SET [field] = REGEXP_REPLACE([field], '[pattern]', '');
UPDATE [table] SET [status] = 'Found' WHERE [text_field] LIKE '%[word]%';
UPDATE [table] SET [field] = DATE_FORMAT([date_field], '%Y-%m-%d');
UPDATE [table] SET [field] = LOG([another_field]);
UPDATE [table] SET [field] = '[new_value]' WHERE [field] REGEXP '[pattern]';
UPDATE [table] SET [field] = CONCAT([field], ' - ', NOW()) WHERE [field] IS NOT NULL;
UPDATE [table] SET [field] = REPLACE(UUID(), '-', '');
UPDATE [table] SET [status] = CASE WHEN MOD([field], 2) = 0 THEN 'Even' ELSE 'Odd' END;
UPDATE [table] SET [field] = [field] * [factor] WHERE [field] > [threshold];
UPDATE [table] SET [field] = SUBSTRING_INDEX([another_field], '[delimiter]', [index]);
UPDATE [table] SET [json_field] = JSON_INSERT([json_field], '$.new_key', '[new_value]');
UPDATE [table] SET [field] = CONCAT(SUBSTRING(MD5(RAND()), 1, 8));
UPDATE [table] SET [field] = TRIM(BOTH 'X' FROM [field]);
UPDATE [table] SET [domain] = SUBSTRING_INDEX([email], '@', -1);
UPDATE [table] SET [field] = SQRT([another_field]);
UPDATE [table] SET [field] = REGEXP_REPLACE([field], '\\s+', ' ');
UPDATE [orders] SET [customer_id] = (SELECT [id] FROM [customers] WHERE [email] = '[new_email]') WHERE [customer_id] = [old_customer_id];
UPDATE [table] SET [field] = LAST_DAY(NOW());
UPDATE [table] SET [date_field] = DATE_ADD(NOW(), INTERVAL (8 - WEEKDAY(NOW())) DAY);
UPDATE [table] SET [timestamp_field] = UNIX_TIMESTAMP([date_field]);
UPDATE [table] SET [field] = REVERSE([field]);
UPDATE [table] SET [word_count] = LENGTH([field]) - LENGTH(REPLACE([field], ' ', '')) + 1;
UPDATE [table] SET [field] = SHA2([field], 256);
UPDATE [table] SET [is_active] = NOT [is_active];




UPDATE [table] SET [field] = [new_value] WHERE [primary_key_field] = [pk_value];
UPDATE [table] SET [field] = [new_value] WHERE [foreign_key_field] = [fk_value];
UPDATE [table1] SET [foreign_key] = (SELECT [new_primary_key] FROM [table2] WHERE [table2].[condition_field] = [value]) WHERE [foreign_key] = [old_value];





alter table [table] add column [field] binary(16);
alter table [table] add column [field] blob;
alter table [table] add column [field] enum('a', 'b', 'c');
alter table [table] add column [field] geometry;
alter table [table] add column [field] json;
alter table [table] add column [field] multipoint;
alter table [table] add column [field] point;
alter table [table] add column [field] set('x', 'y', 'z');
alter table [table] add column [field] text not null;
alter table [table] add column [field] time;
alter table [table] add column [field] timestamp;
alter table [table] add column [field] varbinary(255);
alter table [table] add column [field] xml;
alter table [table] add column [field] year;
alter table [table] add constraint fk_[field] foreign key ([field]) references [table]([field]);
alter table [table] change column [field] [field] date;
alter table [table] drop column [field];
alter table [table] drop column [field];
alter table [table] drop constraint fk_[field];
alter table [table] modify column [field] bigint;
alter table [table] modify column [field] bit;
alter table [table] modify column [field] char(10);
alter table [table] modify column [field] decimal(15,5);
alter table [table] modify column [field] double;
alter table [table] modify column [field] float;
alter table [table] modify column [field] longblob;
alter table [table] modify column [field] longtext;
alter table [table] modify column [field] mediumint;
alter table [table] modify column [field] mediumint;
alter table [table] modify column [field] numeric(8,2);
alter table [table] modify column [field] smallint;
alter table [table] modify column [field] tinyint;
alter table [table] rename column [field] to [field];
alter table [table] add column [field] int not null;
alter table [table] add column [field] varchar(255) default 'n/a';
alter table [table] add column [field] boolean default false;
alter table [table] add column [field] datetime default current_timestamp;
alter table [table] add column [field] float check ([field] >= 0);
alter table [table] add column [field] decimal(10,2) default 0.00;
alter table [table] add column [field] text;
alter table [table] add column [field] varbinary(512);
alter table [table] add column [field] enum('small', 'medium', 'large');
alter table [table] add column [field] set('red', 'green', 'blue');
alter table [table] drop column [field] cascade;
alter table [table] drop column [field] restrict;
alter table [table] modify column [field] char(50);
alter table [table] modify column [field] bigint unsigned;
alter table [table] modify column [field] smallint zerofill;
alter table [table] modify column [field] double precision;
alter table [table] modify column [field] time default '00:00:00';
alter table [table] modify column [field] year default 2024;
alter table [table] modify column [field] tinyint(1) default 1;
alter table [table] modify column [field] bit(1);
alter table [table] modify column [field] binary(32);
alter table [table] modify column [field] varbinary(128);
alter table [table] modify column [field] mediumblob;
alter table [table] modify column [field] mediumtext;
alter table [table] modify column [field] tinyblob;
alter table [table] modify column [field] tinytext;
alter table [table] modify column [field] xml;
alter table [table] modify column [field] point;
alter table [table] modify column [field] geometry;
alter table [table] modify column [field] multipoint;
alter table [table] modify column [field] multilinestring;
alter table [table] modify column [field] multipolygon;
alter table [table] modify column [field] geometrycollection;
alter table [table] change column [field] [field] boolean;
alter table [table] change column [field] [field] double;
alter table [table] change column [field] [field] float(8,2);
alter table [table] change column [field] [field] numeric(12,4);
alter table [table] change column [field] [field] timestamp;
alter table [table] change column [field] [field] character varying(100);
alter table [table] drop primary key;
alter table [table] add foreign key ([field]) references [table]([field]) on delete cascade;
alter table [table] drop foreign key [field];
alter table [table] add check ([field] >= 1);
alter table [table] drop check [field];
alter table [table] add index idx_[field] ([field]);
alter table [table] drop index idx_[field];
alter table [table] add unique ([field]);
alter table [table] drop unique [field];
alter table [table] convert to character set utf8mb4 collate utf8mb4_unicode_ci;
alter table [table] engine = innodb;
alter table [table] auto_increment = 1000;
alter table [table] add partition (partition p1 values less than (1000));
alter table [table] drop partition p1;
alter table [table] add column [field] generated always as ([field] * 2) stored;
alter table [table] add column [field] generated always as ([field] + 10) virtual;
alter table [table] alter column [field] drop default;
alter table [table] alter column [field] set default 0;
alter table [table] alter column [field] set default current_timestamp;
alter table [table] comment = 'updated table structure';
alter table [table] drop default;
alter table [table] add column [field] int not null;
alter table [table] add column [field] varchar(255) default 'n/a';
alter table [table] add column [field] boolean default false;
alter table [table] add column [field] datetime default current_timestamp;
alter table [table] add column [field] float check ([field] >= 0);
alter table [table] add column [field] decimal(10,2) default 0.00;
alter table [table] add column [field] text;
alter table [table] add column [field] json;
alter table [table] add column [field] varbinary(512);
alter table [table] add column [field] enum('small', 'medium', 'large');
alter table [table] add column [field] set('red', 'green', 'blue');
alter table [table] drop column [field];
alter table [table] drop column [field] cascade;
alter table [table] drop column [field] restrict;
alter table [table] modify column [field] char(50);
alter table [table] modify column [field] bigint unsigned;
alter table [table] modify column [field] smallint zerofill;
alter table [table] modify column [field] double precision;
alter table [table] modify column [field] time default '00:00:00';
alter table [table] modify column [field] year default 2024;
alter table [table] modify column [field] tinyint(1) default 1;
alter table [table] modify column [field] bit(1);
alter table [table] modify column [field] binary(32);
alter table [table] modify column [field] varbinary(128);
alter table [table] modify column [field] longblob;
alter table [table] modify column [field] longtext;
alter table [table] modify column [field] mediumblob;
alter table [table] modify column [field] mediumtext;
alter table [table] modify column [field] tinyblob;
alter table [table] modify column [field] tinytext;
alter table [table] modify column [field] xml;
alter table [table] modify column [field] point;
alter table [table] modify column [field] geometry;
alter table [table] modify column [field] multipoint;
alter table [table] modify column [field] multilinestring;
alter table [table] modify column [field] multipolygon;
alter table [table] modify column [field] geometrycollection;
alter table [table] rename column [field] to [field];
alter table [table] change column [field] [field] boolean;
alter table [table] change column [field] [field] double;
alter table [table] change column [field] [field] float(8,2);
alter table [table] change column [field] [field] numeric(12,4);
alter table [table] change column [field] [field] timestamp;
alter table [table] change column [field] [field] character varying(100);
alter table [table] add primary key ([field]);
alter table [table] drop primary key;
alter table [table] add foreign key ([field]) references [table]([field]) on delete cascade;
alter table [table] drop foreign key [field];
alter table [table] add check ([field] >= 1);
alter table [table] drop check [field];
alter table [table] add index idx_[field] ([field]);
alter table [table] drop index idx_[field];
alter table [table] add unique ([field]);
alter table [table] drop unique [field];
alter table [table] convert to character set utf8mb4 collate utf8mb4_unicode_ci;
alter table [table] engine = innodb;
alter table [table] auto_increment = 1000;
alter table [table] add partition (partition p1 values less than (1000));
alter table [table] drop partition p1;
alter table [table] add column [field] generated always as ([field] * 2) stored;
alter table [table] add column [field] generated always as ([field] + 10) virtual;
alter table [table] alter column [field] drop default;
alter table [table] alter column [field] set default 0;
alter table [table] alter column [field] set default current_timestamp;
alter table [table] comment = 'updated table structure';
alter table [table] drop default;
alter table [table] add column [field] int not null;
alter table [table] add column [field] varchar(255) default 'n/a';
alter table [table] add column [field] boolean default false;
alter table [table] add column [field] datetime default current_timestamp;
alter table [table] add column [field] float check ([field] >= 0);
alter table [table] add column [field] decimal(10,2) default 0.00;
alter table [table] add column [field] text;
alter table [table] add column [field] json;
alter table [table] add column [field] varbinary(512);
alter table [table] add column [field] enum('small', 'medium', 'large');
alter table [table] add column [field] set('red', 'green', 'blue');
alter table [table] drop column [field];
alter table [table] drop column [field] cascade;
alter table [table] drop column [field] restrict;
alter table [table] modify column [field] char(50);
alter table [table] modify column [field] bigint unsigned;
alter table [table] modify column [field] smallint zerofill;
alter table [table] modify column [field] double precision;
alter table [table] modify column [field] time default '00:00:00';
alter table [table] modify column [field] year default 2024;
alter table [table] modify column [field] tinyint(1) default 1;
alter table [table] modify column [field] bit(1);
alter table [table] modify column [field] binary(32);
alter table [table] modify column [field] varbinary(128);
alter table [table] modify column [field] longblob;
alter table [table] modify column [field] longtext;
alter table [table] modify column [field] mediumblob;
alter table [table] modify column [field] mediumtext;
alter table [table] modify column [field] tinyblob;
alter table [table] modify column [field] tinytext;
alter table [table] modify column [field] xml;
alter table [table] modify column [field] point;
alter table [table] modify column [field] geometry;
alter table [table] modify column [field] multipoint;
alter table [table] modify column [field] multilinestring;
alter table [table] modify column [field] multipolygon;
alter table [table] modify column [field] geometrycollection;
alter table [table] rename column [field] to [field];
alter table [table] change column [field] [field] boolean;
alter table [table] change column [field] [field] double;
alter table [table] change column [field] [field] float(8,2);
alter table [table] change column [field] [field] numeric(12,4);
alter table [table] change column [field] [field] timestamp;
alter table [table] change column [field] [field] character varying(100);
alter table [table] add primary key ([field]);
alter table [table] drop primary key;
alter table [table] add foreign key ([field]) references [table]([field]) on delete cascade;
alter table [table] drop foreign key [field];
alter table [table] add check ([field] >= 1);
alter table [table] drop check [field];
alter table [table] add index idx_[field] ([field]);
alter table [table] drop index idx_[field];
alter table [table] add unique ([field]);
alter table [table] drop unique [field];
alter table [table] convert to character set utf8mb4 collate utf8mb4_unicode_ci;
alter table [table] engine = innodb;
alter table [table] auto_increment = 1000;
alter table [table] add partition (partition p1 values less than (1000));
alter table [table] drop partition p1;
alter table [table] add column [field] generated always as ([field] * 2) stored;
alter table [table] add column [field] generated always as ([field] + 10) virtual;
alter table [table] alter column [field] drop default;
alter table [table] alter column [field] set default 0;
alter table [table] alter column [field] set default current_timestamp;
alter table [table] comment = 'updated table structure';
alter table [table] drop default;
alter table [table] add column [field] int not null;
alter table [table] add column [field] varchar(255) default 'n/a';
alter table [table] add column [field] boolean default false;
alter table [table] add column [field] datetime default current_timestamp;
alter table [table] add column [field] float check ([field] >= 0);
alter table [table] add column [field] decimal(10,2) default 0.00;
alter table [table] add column [field] text;
alter table [table] add column [field] json;
alter table [table] add column [field] varbinary(512);
alter table [table] add column [field] enum('small', 'medium', 'large');
alter table [table] add column [field] set('red', 'green', 'blue');
alter table [table] drop column [field];
alter table [table] drop column [field] cascade;
alter table [table] drop column [field] restrict;
alter table [table] modify column [field] char(50);
alter table [table] modify column [field] bigint unsigned;
alter table [table] modify column [field] smallint zerofill;
alter table [table] modify column [field] double precision;
alter table [table] modify column [field] time default '00:00:00';
alter table [table] modify column [field] year default 2024;
alter table [table] modify column [field] tinyint(1) default 1;
alter table [table] modify column [field] bit(1);
alter table [table] modify column [field] binary(32);
alter table [table] modify column [field] varbinary(128);
alter table [table] modify column [field] longblob;
alter table [table] modify column [field] longtext;
alter table [table] modify column [field] mediumblob;
alter table [table] modify column [field] mediumtext;
alter table [table] modify column [field] tinyblob;
alter table [table] modify column [field] tinytext;
alter table [table] modify column [field] xml;
alter table [table] modify column [field] point;
alter table [table] modify column [field] geometry;
alter table [table] modify column [field] multipoint;
alter table [table] modify column [field] multilinestring;
alter table [table] modify column [field] multipolygon;
alter table [table] modify column [field] geometrycollection;
alter table [table] rename column [field] to [field];
alter table [table] change column [field] [field] boolean;
alter table [table] change column [field] [field] double;
alter table [table] change column [field] [field] float(8,2);
alter table [table] change column [field] [field] numeric(12,4);
alter table [table] change column [field] [field] timestamp;
alter table [table] change column [field] [field] character varying(100);
alter table [table] add primary key ([field]);
alter table [table] drop primary key;
alter table [table] add foreign key ([field]) references [table]([field]) on delete cascade;
alter table [table] drop foreign key [field];
alter table [table] add check ([field] >= 1);
alter table [table] drop check [field];
alter table [table] add index idx_[field] ([field]);
alter table [table] drop index idx_[field];
alter table [table] add unique ([field]);
alter table [table] drop unique [field];
alter table [table] convert to character set utf8mb4 collate utf8mb4_unicode_ci;
alter table [table] engine = innodb;
alter table [table] auto_increment = 1000;
alter table [table] add partition (partition p1 values less than (1000));
alter table [table] drop partition p1;
alter table [table] add column [field] generated always as ([field] * 2) stored;
alter table [table] add column [field] generated always as ([field] + 10) virtual;
alter table [table] alter column [field] drop default;
alter table [table] alter column [field] set default 0;
alter table [table] alter column [field] set default current_timestamp;
alter table [table] comment = 'updated table structure';
alter table [table] drop default;
alter table [table] enable keys;
alter table [table] disable keys;
alter table [table] rename index idx_old_name to idx_new_name;
alter table [table] force row format = c
drop table if exists [table];
drop database [table];
drop database if exists [table];
drop column [field] from [table];
alter table [table] drop column [field];
drop index [field] on [table];
drop index if exists [field] on [table];
alter table [table] drop index [field];
drop view [table];
drop view if exists [table];
drop function [table];
drop function if exists [table];
drop procedure [table];
drop procedure if exists [table];
drop trigger [table];
drop trigger if exists [table];
drop sequence [table];
drop sequence if exists [table];
drop event [table];
drop event if exists [table];
drop user [table];
drop user if exists [table];
drop role [table];
drop role if exists [table];
drop policy [table];
drop policy if exists [table];
drop rule [table];
drop rule if exists [table];
drop domain [table];
drop domain if exists [table];
drop type [table];
drop type if exists [table];
drop aggregate [table];
drop aggregate if exists [table];
drop constraint [field] from [table];
alter table [table] drop constraint [field];
drop foreign key [field] from [table];
alter table [table] drop foreign key [field];
drop primary key from [table];
alter table [table] drop primary key;
drop check [field] from [table];
alter table [table] drop check [field];
drop default [field] from [table];
alter table [table] alter column [field] drop default;
drop partition [field] from [table];
alter table [table] drop partition [field];
drop temporary table [table];
drop temporary table if exists [table];
drop fulltext index [field] on [table];
drop spatial index [field] on [table];
drop hash index [field] on [table];
drop unique index [field] on [table];
drop materialized view [table];
drop materialized view if exists [table];
drop operator [table];
drop operator if exists [table];
drop cast [table];
drop cast if exists [table];
drop collation [table];
drop collation if exists [table];
drop server [table];
drop server if exists [table];
drop language [table];
drop language if exists [table];
drop conversion [table];
drop conversion if exists [table];
drop text search configuration [table];
drop text search configuration if exists [table];
drop text search dictionary [table];
drop text search dictionary if exists [table];
drop text search parser [table];
drop text search parser if exists [table];
drop text search template [table];
drop text search template if exists [table];
drop publication [table];
drop publication if exists [table];
drop subscription [table];
drop subscription if exists [table];
drop index concurrently [field] on [table];
drop tablespace [table];
drop tablespace if exists [table];
drop foreign data wrapper [table];
drop foreign data wrapper if exists [table];
drop extension [table];
drop extension if exists [table];
drop group [table];
drop group if exists [table];
drop membership [table];
drop membership if exists [table];
drop logical replication slot [table];
drop logical replication slot if exists [table];
drop statistics [table];
drop statistics if exists [table];
drop columnstore index [field] on [table];
drop proxy user [table];
drop proxy user if exists [table];
drop security label [table];
drop security label if exists [table];
drop storage policy [table];
drop storage policy if exists [table];
drop lob storage [table];
drop lob storage if exists [table];
drop row access policy [table];
drop row access policy if exists [table];
drop archive log [table];
drop archive log if exists [table];
drop table [table];
drop table if exists [table];
drop database [table];
drop database if exists [table];
drop column [field] from [table];
alter table [table] drop column [field];
drop index [field] on [table];
drop index if exists [field] on [table];
alter table [table] drop index [field];
drop view [table];
drop view if exists [table];
drop function [table];
drop function if exists [table];
drop procedure [table];
drop procedure if exists [table];
drop trigger [table];
drop trigger if exists [table];
drop sequence [table];
drop sequence if exists [table];
drop event [table];
drop event if exists [table];
drop user [table];
drop user if exists [table];
drop role [table];
drop role if exists [table];
drop policy [table];
drop policy if exists [table];
drop rule [table];
drop rule if exists [table];
drop domain [table];
drop domain if exists [table];
drop type [table];
drop type if exists [table];
drop aggregate [table];
drop aggregate if exists [table];
drop constraint [field] from [table];
alter table [table] drop constraint [field];
drop foreign key [field] from [table];
alter table [table] drop foreign key [field];
drop primary key from [table];
alter table [table] drop primary key;
drop check [field] from [table];
alter table [table] drop check [field];
drop default [field] from [table];
alter table [table] alter column [field] drop default;
drop partition [field] from [table];
alter table [table] drop partition [field];
drop temporary table [table];
drop temporary table if exists [table];
drop fulltext index [field] on [table];
drop spatial index [field] on [table];
drop hash index [field] on [table];
drop unique index [field] on [table];
drop materialized view [table];
drop materialized view if exists [table];
drop operator [table];
drop operator if exists [table];
drop cast [table];
drop cast if exists [table];
drop collation [table];
drop collation if exists [table];
drop server [table];
drop server if exists [table];
drop language [table];
drop language if exists [table];
drop conversion [table];
drop conversion if exists [table];
drop text search configuration [table];
drop text search configuration if exists [table];
drop text search dictionary [table];
drop text search dictionary if exists [table];
drop text search parser [table];
drop text search parser if exists [table];
drop text search template [table];
drop text search template if exists [table];
drop publication [table];
drop publication if exists [table];
drop subscription [table];
drop subscription if exists [table];
drop index concurrently [field] on [table];
drop tablespace [table];
drop tablespace if exists [table];
drop foreign data wrapper [table];
drop foreign data wrapper if exists [table];
drop extension [table];
drop extension if exists [table];
drop group [table];
drop group if exists [table];
drop membership [table];
drop membership if exists [table];
drop logical replication slot [table];
drop logical replication slot if exists [table];
drop statistics [table];
drop statistics if exists [table];
drop columnstore index [field] on [table];
drop proxy user [table];
drop proxy user if exists [table];
drop security label [table];
drop security label if exists [table];
drop storage policy [table];
drop storage policy if exists [table];
drop lob storage [table];
drop lob storage if exists [table];
drop row access policy [table];
drop row access policy if exists [table];
drop archive log [table];
drop archive log if exists [table];
drop session [table];
drop connection [table];
drop user mapping for [table];
drop index if exists idx_[field] on [table];
drop procedure if exists [table] restrict;
drop function if exists [table] cascade;
drop tablespace [table] including contents and datafiles;
drop database [table] force;
drop table [table] purge;
drop sequence [table] restrict;
drop policy [table] on [table];
drop masking policy [table];
drop audit policy [table];
drop resource group [table];
drop resource group if exists [table];
drop service [table];
drop service if exists [table];
drop role [table] cascade;
drop user [table] cascade;
drop profile [table];
drop keystore [table];
drop secret [table];
drop encryption key [table];
drop database link [table];
drop workload group [table];
grant all privileges on [value].* to '[value]'@'localhost';
grant select, insert, update on [value].* to '[value]'@'%';
grant create, drop on [value].* to '[value]'@'localhost';
grant execute on [value].* to '[value]'@'%';
grant usage on [value].* to '[value]'@'localhost';
grant select, insert, update on [table] to '[value]'@'localhost';
grant delete on [table] to '[value]'@'%';
grant all privileges on [table] to '[value]'@'localhost';
grant references on [table] to '[value]'@'%';
grant alter, index on [table] to '[value]'@'localhost';
grant select ([field]) on [table] to '[value]'@'localhost';
grant update ([field]) on [table] to '[value]'@'%';
grant insert ([field]) on [table] to '[value]'@'localhost';
grant references ([field]) on [table] to '[value]'@'%';
grant execute on procedure [value].[value] to '[value]'@'localhost';
grant execute on function [value].[value] to '[value]'@'%';
grant select on [value].[value] to '[value]'@'localhost';
grant insert, update, delete on [value].[value] to '[value]'@'%';
grant usage, select on sequence [value].[value] to '[value]'@'localhost';
grant all privileges on sequence [value].[value] to '[value]'@'%';
grant [value] to '[value]'@'localhost';
grant [value] to '[value]'@'%';
grant super, process, reload on *.* to '[value]'@'localhost';
grant show databases on *.* to '[value]'@'%';
grant lock tables on *.* to '[value]'@'localhost';
grant create temporary tables on [value].* to '[value]'@'localhost';
grant trigger on [value].* to '[value]'@'localhost';
grant replication client on *.* to '[value]'@'%';
grant replication slave on *.* to '[value]'@'localhost';
grant event on [value].* to '[value]'@'localhost';
grant system_user on *.* to '[value]'@'localhost';
grant system_variables_admin on *.* to '[value]'@'%';
revoke all privileges on [value].* from '[value]'@'localhost';
revoke select, insert, update on [value].* from '[value]'@'%';
revoke create, drop on [value].* from '[value]'@'localhost';
revoke execute on [value].* from '[value]'@'%';
revoke usage on [value].* from '[value]'@'localhost';
revoke select, insert, update on [table] from '[value]'@'localhost';
revoke delete on [table] from '[value]'@'%';
revoke all privileges on [table] from '[value]'@'localhost';
revoke references on [table] from '[value]'@'%';
revoke alter, index on [table] from '[value]'@'localhost';
revoke select ([field]) on [table] from '[value]'@'localhost';
revoke update ([field]) on [table] from '[value]'@'%';
revoke insert ([field]) on [table] from '[value]'@'localhost';
revoke references ([field]) on [table] from '[value]'@'%';
revoke execute on procedure [value].[value] from '[value]'@'localhost';
revoke execute on function [value].[value] from '[value]'@'%';
revoke select on [value].[value] from '[value]'@'localhost';
revoke insert, update, delete on [value].[value] from '[value]'@'%';
revoke usage, select on sequence [value].[value] from '[value]'@'localhost';
revoke all privileges on sequence [value].[value] from '[value]'@'%';
revoke [value] from '[value]'@'localhost';
revoke [value] from '[value]'@'%';
revoke super, process, reload on *.* from '[value]'@'localhost';
revoke show databases on *.* from '[value]'@'%';
revoke lock tables on *.* from '[value]'@'localhost';
revoke create temporary tables on [value].* from '[value]'@'localhost';
revoke trigger on [value].* from '[value]'@'localhost';
revoke replication client on *.* from '[value]'@'%';
revoke replication slave on *.* from '[value]'@'localhost';
revoke event on [value].* from '[value]'@'localhost';
revoke system_user on *.* from '[value]'@'localhost';
revoke system_variables_admin on *.* from '[value]'@'%';



alter table [table] add column [field] binary([value]);
alter table [table] add column [field] blob;
alter table [table] add column [field] enum('[value]', '[value]', '[value]');
alter table [table] add column [field] geometry;
alter table [table] add column [field] json;
alter table [table] add column [field] multipoint;
alter table [table] add column [field] point;
alter table [table] add column [field] set('[value]', '[value]', '[value]');
alter table [table] add column [field] text not null;
alter table [table] add column [field] time;
alter table [table] add column [field] timestamp;
alter table [table] add column [field] varbinary([value]);
alter table [table] add column [field] int not null;
alter table [table] add column [field] varchar([value]) default '[value]';
alter table [table] add column [field] boolean default [value];
alter table [table] add column [field] datetime default current_timestamp;
alter table [table] add column [field] float check ([field] >= [value]);
alter table [table] add column [field] decimal([value],[value]) default [value];
alter table [table] add column [field] varbinary([value]);
alter table [table] add column [field] enum('[value]', '[value]', '[value]');
alter table [table] add column [field] set('[value]', '[value]', '[value]');
alter table [table] add column [field] generated always as ([field] * [value]) stored;
alter table [table] add column [field] generated always as ([field] + [value]) virtual;


alter table [table] modify column [field] bigint;
alter table [table] modify column [field] bit;
alter table [table] modify column [field] char([value]);
alter table [table] modify column [field] decimal([value],[value]);
alter table [table] modify column [field] double;
alter table [table] modify column [field] float;
alter table [table] modify column [field] longblob;
alter table [table] modify column [field] longtext;
alter table [table] modify column [field] mediumint;
alter table [table] modify column [field] numeric([value],[value]);
alter table [table] modify column [field] smallint;
alter table [table] modify column [field] tinyint;
alter table [table] modify column [field] char([value]);
alter table [table] modify column [field] bigint unsigned;
alter table [table] modify column [field] smallint zerofill;
alter table [table] modify column [field] double precision;
alter table [table] modify column [field] time default '[value]';
alter table [table] modify column [field] year default [value];
alter table [table] modify column [field] tinyint([value]) default [value];
alter table [table] modify column [field] bit([value]);
alter table [table] modify column [field] binary([value]);
alter table [table] modify column [field] varbinary([value]);
alter table [table] modify column [field] mediumblob;
alter table [table] modify column [field] mediumtext;
alter table [table] modify column [field] tinyblob;
alter table [table] modify column [field] tinytext;
alter table [table] modify column [field] point;
alter table [table] modify column [field] geometry;
alter table [table] modify column [field] multipoint;
alter table [table] modify column [field] multilinestring;
alter table [table] modify column [field] multipolygon;
alter table [table] modify column [field] geometrycollection;


alter table [table] change column [field] [field] date;
alter table [table] change column [field] [field] boolean;
alter table [table] change column [field] [field] double;
alter table [table] change column [field] [field] float([value],[value]);
alter table [table] change column [field] [field] numeric([value],[value]);
alter table [table] change column [field] [field] timestamp;
alter table [table] change column [field] [field] varchar([value]);
alter table [table] rename column [field] to [field];


alter table [table] drop column [field];


alter table [table] add constraint fk_[field] foreign key ([field]) references [table]([field]);
alter table [table] add foreign key ([field]) references [table]([field]) on delete [value];
alter table [table] add check ([field] >= [value]);
alter table [table] add primary key ([field]);
alter table [table] add unique ([field]);
alter table [table] add index idx_[field] ([field]);


alter table [table] drop constraint fk_[field];
alter table [table] drop foreign key fk_[field];
alter table [table] drop check [value];
alter table [table] drop primary key;
alter table [table] drop index idx_[field];
alter table [table] drop unique [field];

alter table [table] convert to character set [value] collate [value];
alter table [table] engine = [value];
alter table [table] auto_increment = [value];
alter table [table] comment = '[value]';
alter table [table] enable keys;
alter table [table] disable keys;
alter table [table] rename index idx_[field] to idx_[field];

alter table [table] add partition (partition [value] values less than ([value]));
alter table [table] drop partition [value];

alter table [table] alter column [field] drop default;
alter table [table] alter column [field] set default [value];
alter table [table] alter column [field] set default current_timestamp;

drop table if exists [table];
drop database [table];
drop database if exists [table];
alter table [table] drop column [field];
drop index [field] on [table];
drop index if exists [field] on [table];
alter table [table] drop index [field];
drop view [table];
drop view if exists [table];
drop function [table];
drop function if exists [table];
drop procedure [table];
drop procedure if exists [table];
drop trigger [table];
drop trigger if exists [table];
drop event [table];
drop event if exists [table];

DROP INDEX [value] ON [table];

grant [value] on [value].[value] to '[value]'@'[value]';
grant [value], [value], [value] on [value].[value] to '[value]'@'[value]';
revoke [value] on [value].[value] from '[value]'@'[value]';
revoke [value], [value], [value] on [value].[value] from '[value]'@'[value]';

alter table [table] force row format = compact;
alter table [table] rename index idx_old_name to idx_new_name;

drop function if exists [table] cascade;
drop procedure if exists [table] restrict;
drop tablespace [table] including contents and datafiles;
drop database [table] force;
drop table [table] purge;
drop sequence [table] restrict;
drop policy [table] on [table];
drop masking policy [table];
drop audit policy [table];
drop resource group [table];
drop resource group if exists [table];
drop service [table];
drop service if exists [table];
drop role [table] cascade;
drop user [table] cascade;
drop profile [table];
drop keystore [table];
drop secret [table];
drop encryption key [table];
drop database link [table];
drop workload group [table];
drop session [table];
drop connection [table];
drop user mapping for [table];

grant system_user on *.* to '[value]'@'localhost';
grant system_variables_admin on *.* to '[value]'@'%';
revoke system_user on *.* from '[value]'@'localhost';
revoke system_variables_admin on *.* from '[value]'@'%';


CREATE TABLE [table] ([field] INT);
CREATE TABLE IF NOT EXISTS [table] ([field] VARCHAR(100));
CREATE TEMPORARY TABLE [table] ([field] DATE);
CREATE VIEW [view_name] AS SELECT [field] FROM [table];
CREATE OR REPLACE VIEW [view_name] AS SELECT [field] FROM [table];
CREATE INDEX [index_name] ON [table] ([field]);
CREATE UNIQUE INDEX [index_name] ON [table] ([field]);
CREATE DATABASE [database];
CREATE SCHEMA [schema];
CREATE USER '[user]'@'localhost' IDENTIFIED BY '[password]';
CREATE ROLE [role_name];
CREATE PROCEDURE [procedure_name]() BEGIN SELECT [field] FROM [table]; END;
CREATE FUNCTION [function_name]() RETURNS INT BEGIN RETURN 1; END;
CREATE TRIGGER [trigger_name] BEFORE INSERT ON [table] FOR EACH ROW SET [field] = NOW();
CREATE EVENT [event_name] ON SCHEDULE EVERY 1 DAY DO UPDATE [table] SET [field] = [value];
CREATE SEQUENCE [sequence_name] START WITH 1 INCREMENT BY 1;
CREATE TYPE [type_name] AS ENUM('A', 'B', 'C');
CREATE MATERIALIZED VIEW [view_name] AS SELECT [field] FROM [table];
CREATE TEMPORARY SEQUENCE [sequence_name];
CREATE AGGREGATE FUNCTION [agg_func] RETURNS INT SONAME '[lib_file]';
CREATE FULLTEXT INDEX [index_name] ON [table] ([field]);
CREATE SPATIAL INDEX [index_name] ON [table] ([field]);
CREATE UNIQUE CONSTRAINT [constraint_name] ON [table] ([field]);
CREATE PRIMARY KEY ON [table] ([field]);
CREATE FOREIGN KEY ([field]) REFERENCES [ref_table]([ref_field]);
CREATE CLUSTERED INDEX [index_name] ON [table] ([field]);
CREATE NONCLUSTERED INDEX [index_name] ON [table] ([field]);
CREATE LOGFILE GROUP [logfile_group_name] ADD UNDOFILE '[file_path]' INITIAL_SIZE 512M;
CREATE SERVER [server_name] FOREIGN DATA WRAPPER mysql OPTIONS (USER '[user]', HOST '[host]', DATABASE '[database]');
CREATE SYNONYM [synonym_name] FOR [object_name];
CREATE PACKAGE [package_name] AS BEGIN PROCEDURE [proc] IS BEGIN NULL; END; END;
CREATE DIRECTORY [dir_name] AS '[path]';
CREATE XML SCHEMA COLLECTION [schema_name] AS '[xml_definition]';
CREATE CERTIFICATE [certificate_name] ENCRYPTION BY PASSWORD = '[password]' WITH SUBJECT = '[subject]';
CREATE LOGIN [login_name] WITH PASSWORD = '[password]';
CREATE RULE [rule_name] AS @value > 0;
CREATE ASSEMBLY [assembly_name] FROM '[path]' WITH PERMISSION_SET = SAFE;
CREATE SECURITY POLICY [policy_name] ADD FILTER PREDICATE [predicate] ON [table];
CREATE RESOURCE POOL [pool_name] WITH (MAX_CPU_PERCENT = 50);
CREATE WORKLOAD GROUP [group_name] USING [pool_name];
CREATE GLOBAL TEMPORARY TABLE [table] ([field] VARCHAR(50));
CREATE LOCAL TEMPORARY TABLE [table] ([field] DATE);
CREATE TEMP TABLE [table] AS SELECT * FROM [another_table];
CREATE INDEX [index_name] ON [table] USING HASH ([field]);
CREATE INDEX [index_name] ON [table] ([field1], [field2]);
CREATE UNIQUE INDEX [index_name] ON [table] ([field1], [field2]);
CREATE TRIGGER [trigger_name] AFTER UPDATE ON [table] FOR EACH ROW BEGIN INSERT INTO [log_table] VALUES (NEW.[field]); END;
CREATE TRIGGER [trigger_name] BEFORE DELETE ON [table] FOR EACH ROW BEGIN INSERT INTO [backup_table] SELECT * FROM [table] WHERE [field] = OLD.[field]; END;
CREATE FUNCTION [function_name] (x INT) RETURNS INT RETURN x * x;
CREATE PROCEDURE [procedure_name] (IN id INT) BEGIN SELECT * FROM [table] WHERE [field] = id; END;
CREATE VIEW [view_name] AS SELECT [field], COUNT(*) FROM [table] GROUP BY [field];
CREATE MATERIALIZED VIEW [view_name] AS SELECT * FROM [table] WHERE [field] IS NOT NULL;
CREATE DATABASE IF NOT EXISTS [database];
CREATE TABLESPACE [tablespace_name] ADD DATAFILE '[path]' SIZE 100M;
CREATE FULLTEXT INDEX [index_name] ON [table] ([field]);
CREATE UNIQUE INDEX [index_name] ON [table] ([field]) WHERE [field] IS NOT NULL;
CREATE TEMPORARY TABLE IF NOT EXISTS [table] ([field] TEXT);
CREATE ROLE IF NOT EXISTS [role_name];
CREATE SCHEMA IF NOT EXISTS [schema_name];
CREATE SERVER [server_name] FOREIGN DATA WRAPPER postgres OPTIONS (HOST '[host]', DATABASE '[database]', USER '[user]', PASSWORD '[password]');

